#!/usr/bin/env ruby

VERSION = "0.1.0"

require 'thor'
require 'fileutils'
require 'tilt'
require 'colorize'

=begin

This file, and Deplot itself, consist/s of three major parts:

1. The 'DeplotRenderer' class
  contains all the logic of deplot and the rendering process
2. The DSL methods
  is the 'interface' to deplot, accessible via the Deplotfile
3. The 'Deplot' CLI class
  provides all command line methods to Thor

This seemed the least complex way to do it; if you can think
of any simplifications or suggestions for alternative designs,
please submit them to the issue tracker. Thanks!

=end

#
# DeplotRenderer, the class with the render logic
#

class DeplotRenderer
  attr_accessor :layout
  
  def alert s
    puts " ---->#{s}".yellow
  end
  
  def initialize type, files, base_dir
    @rendered = false
    @read = false
    @sources = files.collect { |file| {:filename => file} }
    @base_dir = base_dir
    @layout = ""
    @type = type
  end
  def render
    return if @type == "media"
    read if @read == false
    puts "Rendering..."
    @rendered = true
    @sources.each do |source|
      renderer = Tilt[source[:filename]]
      unless renderer.nil?
        source[:content] = renderer.new { source[:content] }.render
      else
        puts "No Tilt renderer found for '#{source[:filename]}', falling back to echo.".yellow
      end
    end
  end
  def read
    return if @type == "media"
    puts "Reading files..."
    @sources.each do |source|
      source[:content] = File.read source[:filename]
      puts "  Read '#{source[:filename]}'."
    end
    @read = true
  end
  def filter options
    if options.has_key? :only or options.has_key? :exclude
      filter_type = (options.has_key? :only) ? :only : :exclude
      options[filter_type].each do |filter|
        @sources.send (filter_type == :only ? :keep_if : :delete_if) do |source|
          file = source[:filename]
          if filter.is_a? Regexp
            filter =~ file
          else
            filter == file || @base_dir + filter == file
          end
        end
      end
    else
      alert "filter: No valid argument/s found."
    end
  end
  def apply module_name, *args
    begin
      module_const = module_name.to_s.split("_").collect { |s| s.capitalize }.join()
      the_module = Kernel.const_get(module_const).new
    rescue
      raise "'#{module_name}' not defined! Maybe not 'use'd?"
    end
    puts "Applying '#{module_name}'..."
    # Prepare module
    module_type = nil
    if the_module.is_a? DeplotPreprocessor
      raise "Cannot preprocess if already rendered! (module '#{module_name}')" if @rendered == true
      read if @read == false
      module_type = :preprocess
    elsif the_module.is_a? DeplotProcessor
      read if @read == false #Â No preprocessors
      render if @rendered == false
      module_type = :process
    elsif the_module.is_a? DeplotFilter  
      module_type = :filter
    else
      raise "'#{module_name}' is not a deplot module!"
    end  
    # Apply to each source
    @sources.each do |source|
      the_module.send module_type, source, args
    end
  end
  def copy_to copy_dir
    puts "copy_to: Media not yet supported.".red
  end
  def output_to output_dir
    unless @type == "documents"
      puts "Media not yet supported.".red
      return
    end
    render if @rendered == false
    puts "Writing files..."
    @sources.each do |source|
      output_dir += "/" unless output_dir =~ /\/$/
      output_path = output_dir + source[:filename].gsub(/^#{@base_dir}/, '')
      extname = File.extname(output_path)
      if extname == ""
        output_path += ".html"
      else
        output_path.gsub! /#{extname}$/, ".html"
      end
      FileUtils.mkdir_p(File.dirname(output_path))
      File.open(output_path, "w") do |file|
        if @layout == ""
          file.write source[:content]
        else
          file.write Tilt.new("assets/#{@layout}").render{ source[:content] }
        end
      end 
      puts "  Wrote to file '#{output_path}'."
    end
  end
  def collect_in output_file
    unless @type == "documents"
      puts "Media not yet supported.".red
      return
    end
    puts "Writing file..."
    sources_contents = @sources.collect{ |source| source[:content] }.join
    FileUtils.mkdir_p(File.dirname(output_file))
    File.open(output_file, "w") do |file|
      if @layout == ""
        file.write sources_contents
      else
        file.write Tilt.new("assets/#{@layout}").render{ sources_contents }
      end
    end  
    puts "  Wrote to file '#{output_file}'."
  end
end

$current_instance = nil

# Module base classes

class DeplotFilter
  def filter sources, arguments
    raise "Module error: 'filter' method is not defined!"
  end
end
class DeplotPreprocessor
  def preprocess sources, arguments
    raise "Module error: 'preprocess' method is not defined!"
  end
end
class DeplotProcessor
  def process sources, arguments
    raise "Module error: 'process' method is not defined!"
  end
end

#
# Deplot DSL, the language of the Deplotfile
#

def use module_name
  puts "Loading '#{module_name}'..."
  require "./modules/#{module_name}.rb"
end

# Assign methods
["layout"].each do |variable_name|
  self.class.send :define_method, variable_name do |*args|
    unless $current_instance.nil?
      $current_instance.send("#{variable_name}=", *args)
    end
  end
end

# Basic methods
["filter", "apply", "copy_to"].each do |method_name|
  self.class.send :define_method, method_name do |*args|
    unless $current_instance.nil?
      $current_instance.send(method_name, *args)
    end
  end
end

# Output methods
["output_to", "collect_in"].each do |method_name|
  self.class.send :define_method, method_name do |path, &block|
    unless $current_instance.nil?
      backup = Marshal.load(Marshal.dump($current_instance))
      block.call unless block.nil?
      $current_instance.send(method_name, path)
      $current_instance = backup
    end
  end
end

# DSL blocks
["media", "documents"].each do |type|
  self.class.send :define_method, "#{type}_in" do |dir, &block|
    # Maybe run $current_instance's output_to, define default behaviour?
    # If so, remember to output after 'load "Deplotfile" too.
    base = "documents/#{dir}/"
    $current_instance = DeplotRenderer.new(type, Dir.glob(base + "*") - [".", "..", ".DS_STORE"], base)
    block.call
  end
end

#
# Deplot Thor CLI, all the methods of the CLI
#

class Deplot < Thor
  desc "version", "Show the installed deplot gem's version."
  def version
    puts "Deplot version #{VERSION}."
  end
  desc "make", "Build the deplot project in the current directory"
  def make
    puts "Deplot #{VERSION} will re/build the project.".green
    unless File.exist? "Deplotfile"
      puts "Deplotfile not found. Exiting...".red
      return
    end
    $LOAD_PATH.unshift(Dir.pwd)
    load "Deplotfile"
  end
end
Deplot.start