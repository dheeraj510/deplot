#!/usr/bin/env ruby

VERSION = "0.1.0"

require 'thor'
require 'fileutils'
require 'tilt'
require 'colorize'

class DeplotRenderer
  attr_accessor :output_to, :layout
  alias :copy_to= :output_to=
  
  def alert s
    puts " ---->#{s}".yellow
  end
  
  def render
    return if @type == "media"
    read if @read == false
    puts "Rendering..."
    @rendered = true
    @sources.each do |source|
      # Render content
      file = source[:filename]
      renderer = Tilt[file]
      unless renderer.nil?
        source[:content] = renderer.new { source[:content] }.render
      else
        puts "No Tilt renderer found for '#{source[:filename]}', falling back to echo.".yellow
      end
      # Render layout
      unless @layout == ""
        Tilt.new("assets/#{@layout}").render{ source[:content] }
      end
    end
  end
  def read
    return if @type == "media"
    puts "Reading files..."
    @sources.collect do |source|
      source[:content] = File.read source[:filename]
      puts "  Read '#{source[:filename]}'."
      source
    end
    @read = true
  end
  def initialize type, files, base_dir
    @rendered = false
    @read = false
    @sources = files.collect { |file| {:filename => file} }
    @base_dir = base_dir
    @output_to = ""
    @layout = ""
    @type = type
  end
  def filter options
    if options.has_key? :only
      options[:only].each do |only|
        @sources.keep_if do |source|
          file = source[:filename]
          if only.is_a? Regexp
            only =~ file
          else
            only == file || @base_dir + only == file
          end
        end
      end
    elsif options.has_key? :exclude
      options[:exclude].each do |exclude|
        @sources.delete_if do |source|
          file = source[:filename]
          if exclude.is_a? Regexp
            exclude =~ file
          else
            exclude == file || @base_dir + exclude == file
          end
        end
      end
    else
      alert "filter: No valid argument/s found."
    end
  end
  def apply module_name, *args
    begin
      module_const = module_name.to_s.split("_").collect { |s| s.capitalize }.join("")
      the_module = Kernel.const_get(module_const).new
    rescue
      raise "'#{module_name}' not defined! Maybe not 'use'd?"
    end
    puts "Applying '#{module_name}'..."
    if the_module.is_a? DeplotPreprocessor
      raise "Cannot preprocess if already rendered! (module '#{module_name}')" if @rendered == true
      read if @read == false
      @sources.collect do |source|
        the_module.preprocess source, args
        source
      end
    elsif the_module.is_a? DeplotProcessor
      read if @read == false #Â No preprocessors
      render if @rendered == false
      @sources.collect do |source|
        the_module.process source, args
        source
      end
    elsif the_module.is_a? DeplotFilter
      @sources.collect do |source|
        the_module.filter source, args
        source
      end
    else
      raise "'#{module_name}' is not a deplot module!"
    end
  end
  def output
    unless @type == "documents"
      puts "Media not yet supported.".red
      return
    end
    render if @rendered == false
    puts "Writing files..."
    @sources.each do |source|
      @output_to += "/" unless @output_to =~ /\/$/
      output_path = @output_to + source[:filename].gsub(/^#{@base_dir}/, '')
      extname = File.extname(output_path)
      if extname == ""
        output_path += ".html"
      else
        output_path.gsub! /#{extname}$/, ".html"
      end
      FileUtils.mkdir_p(File.dirname(output_path))
      File.open(output_path, "w") do |file|
        file.write source[:content]
      end 
      puts "  Wrote to file '#{output_path}'."
    end
  end
end

$current_instance = nil

# Module base classes

class DeplotFilter
  def filter sources, arguments
    raise "Module error: 'run' method is not defined!"
  end
end
class DeplotPreprocessor
  def preprocess sources, arguments
    raise "Module error: 'run' method is not defined!"
  end
end
class DeplotProcessor
  def process sources, arguments
    raise "Module error: 'run' method is not defined!"
  end
end

# Deplot DSL

def use module_name
  puts "Loading '#{module_name}'..."
  require "./modules/#{module_name}.rb"
end

# Assign methods
["copy_to", "output_to", "layout"].each do |variable_name|
  self.class.send :define_method, variable_name do |*args|
    unless $current_instance.nil?
      $current_instance.send("#{variable_name}=", *args)
    end
  end
end

# Basic methods
["filter", "apply"].each do |method_name|
  self.class.send :define_method, method_name do |*args|
    unless $current_instance.nil?
      $current_instance.send(method_name, *args)
    end
  end
end

# DSL blocks
["media", "documents"].each do |type|
  self.class.send :define_method, "#{type}_in" do |dir, &block|
    $current_instance.output unless $current_instance.nil?
    base = "documents/#{dir}/"
    $current_instance = DeplotRenderer.new(type, Dir.glob(base + "*") - [".", "..", ".DS_STORE"], base)
    block.call
  end
end

# Deplot Thor CLI

class Deplot < Thor
  desc "make", "Build the deplot project in the current directory"
  def make
    puts "Deplot #{VERSION} will re/build the project.".green
    unless File.exist? "Deplotfile"
      puts "Deplotfile not found. Exiting...".red
      return
    end
    $LOAD_PATH.unshift(Dir.pwd)
    load "Deplotfile"
    $current_instance.output unless $current_instance.nil?
  end
end
Deplot.start